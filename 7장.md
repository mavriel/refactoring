# 7. 캡슐화

## 7.1 레코드 캡슐화하기 (Encapsulate Record)

### 언제

- 저장한 값과 계산해서 얻은 값을 구분할 필요가 있을 때

### 절차

1. 레코드를 담은 변수를 캡슐화
2. 레코드를 감싼 단순 클래스로 변수 내용 교체 - 레코드 반환하는 접근자를 만들어 사용
3. 테스트
4. 레코드 대신 클래스 타입의 객체를 반환하는 함수 생성
5. 레코드 반환 함수를 신규 클래스 사용하도록 수정
6. 원본 데이터를 반환하는 접근자와 원본 레코드를 반환하는 함수 제거
7. 테스트
8. 레코드의 필드도 데이터 구조라면, 레코드 캡슐화와 컬렉션 캡슐화하기 적용

## 7.2 컬렉션 캡슐화하기 (Encapsulate Collection)

### 의견/주의사항

- 게터가 컬렉션을 반환하면, 컬렉션을 감싼 클래스가 눈치채지 못한 상태에서 컬렉션의 원소가 바뀜
- 컬렉션 게터를 제공하되 내부 컬렉션의 복제본 반환 추천
- 컬렉션을 사용할때는 항상 복제본을 사용하게 코드 작성

### 절차

1. 컬렉션을 캡슐화하지 않았다면, 변수 캡슐화
2. 원소 추가/제거 함수 추가
3. 정적 검사
4. 컬렉션을 참조하는 부분을 모두 찾아서, 추가/제거 함수 호출로 변경
5. 게터를 수정해 복제본 반환
6. 테스트

## 7.3 기본형을 객체로 바꾸기 (Replace Primitive with Object)

### 언제

- 개발 초기의 간단한 데이터가 단순 출력 이상의 기능을 필요해지는 순간

### 절차

1. 변수캡슐화
2. 단순한 값 클래스 생성. 기존 값을 인수로 받고 값을 반환하는 게터 추가
3. 정적 검사
4. 클래스 인스턴스를 만들어 필드에 저장하도록 세터 수정
5. 신규 클래스의 케터사용하도록 수정
6. 테스트
7. 함수이름 검토

## 7.4 임시 변수를 질의 함수로 바꾸기 (Replace Temp with Query)

### 언제/의견/주의사항

- 긴 함수의 한 부분을 별도 함수로 추출을 원할때 변수들을 함수로 만들면 쉽게 처리 가능
  - 추출한 함수와 원래 함수릐 경계가 확실해 져서, 여러 의존관계나 부수효과를 찾고 제거하는데 도움
- 코드 중복 제거에 도움
- 클래스에 적용할때 효과가 크다
- 항상 같은 결과를 내야하므로, 스냅샷용도의 변수에는 적용하면 안 됨

### 절차

1. 변수 사용할때 사이드이펙트가 있나 확인
2. 읽기전용이 가능한 변수는 읽기 전용으로 변경
3. 테스트
4. 변수 대입문을 함수로 추출 - 같은 이름이 어려우면 함수명을 임시로 직는다. 추출한 함수의 사이드 이펙트 확인
5. 테스트
6. 변수 인라인하기로 임시변수 제거

## 7.5 클래스 추출하기 (Extract Class)

### 언제

- 메서드와 데이터가 너무 많은 클래스
- 일부 데이터와 메서드가 따로 묶일 수 있을 때

### 절차

1. 클래스의 역할을 분리할 방법을 지정
2. 분리될 역할을 담당할 클래스 생성 - 이름도 변경
3. 원래 클래스 생성자에서 새로운 클래스 인스턴트를 생성해 필드에 저장
4. 원본 클래스의 필드를 새 클래스로 이동 - 각각 테스트
5. 메서드 이동 - 저수준 메서드(호출 당하는 메서드)부터 이동
6. 불필요 메서드 제거 및 이름 변경
7. 새 클래스 외부 노출 결정 - 노출시 새 클래스에 참조를 값으로 바꾸기 적용 결정

## 7.6 클래스 인라인하기 (Inline Class)

### 언제

- 특정 클래스에 남은 역할이 거의 없을 때
- 두 클래스의 기능의 배분을 다시 하고 싶을 때
  - 인라인해서 합친후 새로운 클래스 추출이 쉬울 때도 있다.

### 절차

1. 소스 클래스의 public 메서드에 해당하는 메서드(작업자체는 소스 클래스에 위임)를 타겟 클래스에 생성.
2. 소스 클래스의 메서드를 사용하는 코드를 타겟 클래스의 메소드 사용하게 변경. 변경마다 각각 테스트
3. 소스 클래스의 메서드와 필드를 타겟 클래스로 이동. 이동시마다 각각 테스트
4. 소스 클래스 삭제

## 7.7 위임 숨기기 (Hide Delegate)

### 언제

- 위임 객체의 메서드를 사용하는 경우 의존성을 제거하기 위해서

### 절차

1. 위임 객체의 각 메서드에 해당하는 위임 메서드를 서버에 생성
2. 클라이언트가 위임 객체 대신 서버를 호출하게 수정. 각각의 변경마다 테스트
3. 위임 객체를 얻는 접근자 제거
4. 테스트

## 7.8 중개자 제거하기 (Remove Middle Man)

### 언제/의견/주의사항

- 서버 클래스가 그저 중재자의 역할만 하게 되는 경우
- 위임숨기기와 중개자 제거하기의 균형의 판단은 어렵지만, 상황에 따랏 적절하게 리팩토링하면 된다.

### 절차

1. 위임 객체를 얻는 게터를 만든다.
2. 위임 메서드를 호출하는 클라이언트가 모두 이 게터를 거치도록 수정한다. 각각 테스트
3. 모두 수정했다면 위임 메서드 삭제

- 자동 리팩토링 도구 사용시 위임 필드를 캡슐화 후에 메서드를 인라인
