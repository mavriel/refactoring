# 7. 캡슐화

## 7.1 레코드 캡슐화하기 (Encapsulate Record)

### 언제

- 저장한 값과 계산해서 얻은 값을 구분할 필요가 있을 때

### 절차

1. 레코드를 담은 변수를 캡슐화
2. 레코드를 감싼 단순 클래스로 변수 내용 교체 - 레코드 반환하는 접근자를 만들어 사용
3. 테스트
4. 레코드 대신 클래스 타입의 객체를 반환하는 함수 생성
5. 레코드 반환 함수를 신규 클래스 사용하도록 수정
6. 원본 데이터를 반환하는 접근자와 원본 레코드를 반환하는 함수 제거
7. 테스트
8. 레코드의 필드도 데이터 구조라면, 레코드 캡슐화와 컬렉션 캡슐화하기 적용

## 7.2 컬렉션 캡슐화하기 (Encapsulate Collection)

### 의견/주의사항

- 게터가 컬렉션을 반환하면, 컬렉션을 감싼 클래스가 눈치채지 못한 상태에서 컬렉션의 원소가 바뀜
- 컬렉션 게터를 제공하되 내부 컬렉션의 복제본 반환 추천
- 컬렉션을 사용할때는 항상 복제본을 사용하게 코드 작성

### 절차

1. 컬렉션을 캡슐화하지 않았다면, 변수 캡슐화
2. 원소 추가/제거 함수 추가
3. 정적 검사
4. 컬렉션을 참조하는 부분을 모두 찾아서, 추가/제거 함수 호출로 변경
5. 게터를 수정해 복제본 반환
6. 테스트

## 7.3 기본형을 객체로 바꾸기 (Replace Primitive with Object)

### 언제

- 개발 초기의 간단한 데이터가 단순 출력 이상의 기능을 필요해지는 순간

### 절차

1. 변수캡슐화
2. 단순한 값 클래스 생성. 기존 값을 인수로 받고 값을 반환하는 게터 추가
3. 정적 검사
4. 클래스 인스턴스를 만들어 필드에 저장하도록 세터 수정
5. 신규 클래스의 케터사용하도록 수정
6. 테스트
7. 함수이름 검토

## 7.4 임시 변수를 질의 함수로 바꾸기 (Replace Temp with Query)

### 언제/의견/주의사항

- 긴 함수의 한 부분을 별도 함수로 추출을 원할때 변수들을 함수로 만들면 쉽게 처리 가능
  - 추출한 함수와 원래 함수릐 경계가 확실해 져서, 여러 의존관계나 부수효과를 찾고 제거하는데 도움
- 코드 중복 제거에 도움
- 클래스에 적용할때 효과가 크다
- 항상 같은 결과를 내야하므로, 스냅샷용도의 변수에는 적용하면 안 됨

### 절차

1. 변수 사용할때 사이드이펙트가 있나 확인
2. 읽기전용이 가능한 변수는 읽기 전용으로 변경
3. 테스트
4. 변수 대입문을 함수로 추출 - 같은 이름이 어려우면 함수명을 임시로 직는다. 추출한 함수의 사이드 이펙트 확인
5. 테스트
6. 변수 인라인하기로 임시변수 제거

## 7.5 클래스 추출하기 (Extract Class)

### 언제

### 의견/주의사항

### 절차

## 7.6 클래스 인라인하기 (Inline Class)

### 언제

### 의견/주의사항

### 절차

## 7.7 위임 숨기기 (Hide Delegate)

### 언제

### 의견/주의사항

### 절차

## 7.8 중개자 제거하기 (Remove Middle Man)

### 언제

### 의견/주의사항

### 절차
