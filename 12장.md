# 12. 상속 다루기

## 12.1 메서드 올리기 (Pull Up Method)

### 언제/의견/주의사항

- 서브클래스가 중복이 있는 경우
- 각각을 매개변수화 한 다음 메서드를 상속 계층의 위로 올림
- 메서드가 사용하는 필드가 서브클래스에만 있으면, 슈퍼클래스로 올린후 메서드를 올린다.
- 전체 흐름은 비슷하지만 세부 내용이 다르면 템플릿 메서드를 만든다.
-

### 절차

1. 똑같이 동작하는 메서드인지 확인
2. 메서드 안에서 호출하는 다른 메서드와 참조하는 필드들을 슈퍼클래스에서도 호출/참조할 수 있는지 확인
3. 함수 선언 바꾸기로 슈퍼클래스에서 사용할 해태로 통일
4. 슈퍼클래스에 새로운 메서드 생성하고, 대상 메서드의 코드 복사
5. 정적 검사
6. 서브클래스 중 하나의 메서드 제거
7. 테스트
8. 모든 서브클래스의 메서드가 없어질 때까지 하나씩 제거

## 12.2 필드 올리기 (Pull Up Field)

### 언제/의견/주의사항

- 서브클래스들이 독립적으로 개발되거나, 나중에 하나의 계층구조로 리팩터링되서 기능이 중복 되는 경우 (특히 필드 중복)
- 필드들을 분석하고 비슷한 방식으로 사용되면 슈퍼클래스로 끌어올리자
- 클래스정의에 필드가 포함되지 않는 언어라면, 생성자 본문부터 올리자

### 절차

1. 후보 필드들이 사용하는 곳 모두가 같은 방식으로 사용하는지 확인
2. 이름이 다르면 같은 이름으로 변경
3. 슈퍼클래스에 새로운 필드 생성
4. 서브클래스의 필드 제거
5. 테스트

## 12.3 생성자 본문 올리기 (Pull Up Constructor Body)

### 언제/의견/주의사항

- 쉽지 않다면 생성자를 팩터리 함수로 바꾸기를 고려

### 절차

1. 슈퍼클래스에 생성자가 없으면 하나 정의. 서브클래스의 생성자들에서 이 생성자가 호출되는지 확인
2. 문장 슬라이드하기로 공통 문장 모두를 super() 호출 직후로 이동
3. 공통 코드를 슈퍼클래스에 추가하고 서브클래스들에서 제거. 생성자 매개변수 중 공통 코드에서 참조하는 값들을 모두 super()로 건넨다.
4. 테스트
5. 생성자 시작 부분으로 옮길 수 없는 공통 코드에는 함수 추출하기와 메서드 올리기를 차례로 적용

## 12.4 메서드 내리기 (Push Down Method)

### 언제/의견/주의사항

- 특정 서브클래스와만 관련된 메서드는 해당 서브클래스로 옮기는게 좋음

### 절차

1. 대상 메서드를 모든 서브클래스에 복사
2. 슈퍼클래스에서 메서드 제거
3. 테스트
4. 이 메서드를 사용하지 않는 모든 서브클래스에서 제거
5. 테스트

## 12.5 필드 내리기 (Push Down Field)

### 절차

1. 대상 필드를 모든 서브클래스에 정의
2. 슈퍼클래스에서 그 필드 제거
3. 테스트
4. 이 필드를 사용하지 않는 모든 서브클래스에서 제거
5. 테스트

## 12.6 타입 코드를 서브클래스로 바꾸기 (Replace Type Code with Subclasses)

### 언제/의견/주의사항

- 서브클래스의 장점
  - 조건에 따라 다르게 동작하도록 해주는 다형성 제공
  - 특정 타입에서만 의미가 있는 값을 사용하는 필드나 메서드가 있을 때 유용
- 방법
  - 대상 클래스에 직접 적용
  - 타입 코드 자체를 클래스화

### 절차

1. 타입 코드 필드를 자가 캡슐화
2. 타입 코드 값 하나를 선택하여 그 값에 해당하는 서브클래스 생성. 타입 코드 게터 메서드를 오버라이드해 해당 타입 코드의 리터럴 값을 반환
3. 매개변수로 받은 타입 코드와 방금 만든 서브클래스를 매핑하는 선택 로직 생성
4. 테스트
5. 타입 코드값 각각에 대해 서브클래스 생성 및 선택로직 추가 반복. 각각 테스트
6. 타입 코드 필드 제거
7. 테스트
8. 타입 코드 접근자를 이용하는 메서도 모두에 메서드 내리기와 조건부 로직을 다형성으로 바꾸기 적용

## 12.7 서브클래스 제거하기 (Remove Subclass)

### 언제/의견/주의사항

- 소프트웨어 시스템이 성장하면서, 서브클래스의 사용이 점점 줄어드는 경우
- 이 리팩토링을 하는 순간이 왔으면 좋겠다. 서비스도 잘 만들었다는 것이고, 그것이 한번더 업그레이드 되었다는 증거일듯

### 절차

1. 서브클래스의 생성자를 팩터리 함수로 바꾼다
2. 서브클래스의 타입을 검사하는 코드가 있다면 그 검사 코드에 함수 추출하기와 함수 옮기기를 적용해 슈퍼클래스로 옮긴다. 각각 테스트
3. 서브클래스의 타입을 나타내는 필드를 슈퍼클래스에 만든다
4. 서브클래스를 참조하는 메서드가 방금 만든 타입 필드를 쓰도록 수정
5. 서브클래스 삭제
6. 테스트

## 12.8 슈퍼클래스 추출하기 (Extract Superclass)

### 언제/의견/주의사항

- 비슷한 일을 수행하는 두 클래스가 보이면, 상속 매커니즘을 이용해 비슷한 부분을 공통의 슈퍼클래스로 옮겨 담을 수 있다.
- 대안으로 클래스 추출하기가 있지만, 슈퍼클래스 추출하기가 더 쉬운 경우가 많으니 먼저 해보고, 나중에 클래스를 위임으로 바꾸기를 적용해도 된다.

### 절차

1. 빈 슈퍼클래스를 만든다. 원래의 클래스들이 새 클래스를 상속하도록 한다.
2. 테스트
3. 생성자/메서드/필드 올리기를 차례로 적용해 공통 원소를 슈퍼클랫그로 옮긴다.
4. 서브클래스에 남은 메서드들을 검토. 공통되는 부분이 있으면 함수로 추출후 메서드 올리기 적용
5. 원래 클래스들을 사용하는 코드를 검토해 슈퍼클래스의 인터페이스를 사용하게 할지 고민한다.

## 12.9 계층 합치기 (Collapse Hierarchy)

### 언제/의견/주의사항

- 어떤 서브클래스와 슈퍼클래스가 너무 비슷해져서 독립적으로 존재해야 할 이유가 사라지는 경우 합친다.

### 절차

1. 두 클래스 중 제거할 것을 선택
2. 필드/메서드 올리기(또는 내리기)를 적용해 하나의 클래스로 옮긴다.
3. 제거할 클래스를 참조하던 모든 클래스가 남겨질 클래스를 참조하도록 수정
4. 빈 클래스 제거
5. 테스트

## 12.10 서브클래스를 위임으로 바꾸기 (Replace Subclass with Delegate)

### 언제/의견/주의사항

- 상속의 단점
  - 상속은 동작의 여러 이유 중 하나만 기준으로 처리 가능하다
  - 슈퍼클래스를 수정하면 서브클래스의 기능을 해칠 수가 있다.
- 위임
  - 다양한 클래스에 서로 다른 이유로 위임할 수 있다.
  - 상속보다 결합도가 훨씬 약하다

### 절차

1. 생성자를 호출하는 곳이 많다면 생성자를 팩터리 함수로 바꾼다.
2. 위임으로 활용할 빈 클래스를 만든다. 이 클래스의 생성자는 서브클래스에 특화된 데이터를 전부 받아야 하며, 보통 슈퍼클래스를 가리키는 역참조도 필요하다.
3. 위임을 저장할 필드를 슈퍼클래스에 추가한다.
4. 서브클래스 생성 코드를 수정하여 위임 인스턴스를 생성하고 위임 필드에 대입해 초기화한다.
5. 서브클래스의 메서드 중 위임 클래스로 이동할 것을 고른디ㅏ.
6. 함수 옮기기를 적용해 위임 클래스로 옮긴다. 원래 메서드에서 위임하는 코드는 지우지 않는다.
7. 서브클래스 외부에서 원래 메서드를 호출하는 코드가 있다면 서브클래스의 위임 코드를 슈퍼클래스로 옮긴다. 이때 위임이 존재하는지를 검사하는 보호 코드로 감싸야 한다. 호출하는 외부 코드가 없다면 원래 메서드는 죽은 코드가 되므로 제거한다.
8. 테스트
9. 5-8 반복
10. 서브클래스들의 생성자를 호출하는 코드를 찾아서 슈퍼클래스의 생성자를 사용하도록 수정
11. 테스트
12. 서브클래스 삭제

## 12.11 슈퍼클래스를 위임으로 바꾸기 (Replace Superclass with Delegate)

### 언제/의견/주의사항

- 슈퍼클래스의 기능들이 서브클래스에 어울리지 않는다면, 위임을 사용해야 한다.
- 저자는 상속을 우선 사용해보고 나중에 문제 발생시 위임으로 바꾸는 것을 추천

### 절차

1. 슈퍼클래스 객체를 참조하는 필드를 서브 클래스에 만든다. 이 위임 참조를 새로운 슈퍼클래스 인스턴스로 초기화
2. 슈퍼클래스의 동작 각각에 대응하는 전달 함수를 서브클래승에 만든다. 서로 관련된 함수끼리 그룹핑하고 각각 테스트
3. 슈퍼클래스의 동작 모두가 전달 함수로 오버라이드되었다면 상속관계를 끊는다.
