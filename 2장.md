# 2. 리팩터링 원칙
## 2.1 리팩터링 정의
> 리팩터링: 소프트웨어의 겉보기 동작은 그대로 유지한 채 코드를 이해하고 수정하기 쉽도록 내부 구조를 변경하는 기법
* 동작을 보전하는 작은 단계를 순차적으로 연결하여 큰 변화를 만듦
* 리팩터링하는 동안 코드가 항상 정상 작동
* 단계들이 체계적이고 디버깅하는데 시간이 줄어, 작업을 더 빨리 가능
## 2.2 두개의 모자
* 기능추가, 리팩터링을 명확히 구분해서 작업
  * 2가지를 동시에 하지 않음
* 리팩터링시
  * 기능추가 X
  * 테스트 추가 X
    * 인터페이스 변경시만 테스트 수정 - 이것도 요즘은 ide가 자동으로 수정해줌 
* 기능추가시
  * 기존 코드 변경 X
## 2.3 리팩터링하는 이유
1. 소프트웨어 설계가 좋아진다.
   * 규칙적인 리팩터링으로 코드의 구조 지탱
2. 이해하기 쉬워진다.
   * 기억할 것들을 최대한 코드에 담는다.
3. 버그를 쉽게 찾을 수 있다.
   * 구조가 좋아지면서, 버그가 눈에 쉽게 보인다.
4. 프로그래밍 속도가 높아진다.
   * 기존에 작성한 코드를 최대한 활용할 수 있어서 새 기능을 더 빨리 추가
   * 요구사항이 바뀌더라도 설계를 지속해서 개선 가능 
## 2.4 언제 리팩터링해야 할까?
1. 기능 추가 직전 - 준비를 위한 리팩터링
   * 구조를 살짝 바꾸면 다른 작업하기 부분을 찾아 리팩터링한다.
2. 코드 수정전 코드 파악할때 - 이해를 위한 리팩터링
   * 파악할 때마다 코드의 의도가 드러나게 리팩터링
     * 코드 분석시 리팩터링을 하면, 더 깊은 수준까지 이해 가능 
3. 쓰레기 줍기 리팩터링
   * 쉽게 수정가능한 부분만 리팩터링하고, 오래 걸릴 부분은 메모후 나중에 처리
   * **각각의 작은 단계가 코드를 깨뜨리지 않는다.**
4. 계획된 리팩터링과 수시로 하는 리팩터링
   * 뛰어난 개발자는 새 기능을 추가하기 쉽도록 코드를 '수정'하는 것이 기능을 가장 빠르게 추가하는 길일 수 있음을 안다.
   * 나쁜 코드뿐만 아니라 잘 작성된 코드도 끊임없이 리팩터링을 계속해야 한다.
     * 물론 잘 작성된 코드는 리팩터링도 더 쉽다.
   * 따로 업무에 추가하지 않고, 일하는 도중 계속해서 해야됨 
     * **!!! 모든 작업에 리팩터링이 포함되어 있다고 생각**
5. 오래 걸리는 리팩터링
   * 대규모 리팩터링에는 회의적
   * 깨지지 않는 아주 작은 단계의 리팩터링 반복
   * 이것들이 모여서 대규모 리팩터링이 됨
     * 라이브러리 교체시 - 추상 인터페이스 만들고, 신규 라이브러리로 이동 (추상화 갈아타기)
6. 코드 리뷰에 리팩터링 활용하기 
   * 개선사항 찾아보고, 리팩터링하여 쉽게 개선할 것 같으면 해본다.
   * 이때, 더 좋은 아이디어가 나올 때도 있다.
7. 관리자에게는 뭐라고 말해야 할까?
   * 리팩터링은 기능 추가할때 그냥 포함된다고 보면된다.
   * 구조 크게 바꾸는게 리팩터링이 아님. 일반적으로 말하는 리팩터링은 우리의 리팩터링이 아님
8. 리팩터링하지 말아야 할 때
   * 수정할 필요가 없는 코드
   * 새로 만드는게 더 쉬울 때
## 2.5 리팩터링 시 고려할 문제
1. 새 기능 개발 속도 저하
  > 리팩터링의 궁극적인 목적은 개발 속도를 높여서, 더 적은 노력으로 더 많은 가치를 창출하는 것 
   * 리팩터링의 본질은 코드 베이스를 예쁘게 꾸미게 아니다.
   * 오로지 **기간 단축**을 이유로 하는 것이다. 
2. 코드 소유권
   * 코드 소유권이 나눠 있으면 리팩토링에 방해
   * 누구나 변경가능한 방식을 선호 
3. 브랜치
   * 기능 브랜치의 문제점
     * 독립 브랜치로 작업하는 기간이 길어질 수로 merge가 어렵다.
   * 지속적 통합(CI)
     * 최소한 하루에 한번은 마스터에 merge
     * 마스터를 건강하게 유지.
     * 거대한 기능을 잘게 쪼게서 개발
     * 기능 토글 플래그 사용
4. 테스팅 
   * 리팩터링을 위해서는 test code를 마련해야 한다.
   * 테스트에 리소스 투입은 필요하지만, 효과가 좋다.
5. 레거시 코드
   * 프로그램의 틈새를 만들기 - 이때 리팩토링을 사용
   * 부분을 나눠, 조금씩 수정 - 자주 보는 부분을 더 많이 리팩터링 
6. 데이터 베이스 
   * 데이터 마이그레이션 스크립트 작성
   * 접근 코드와 스키마에 대한 구조적 변경을 이 스크립트로 처리 
   * 방법
     1. 새로운 필드를 추가만 하고 사용하지 않음
     2. 기존 필드와 새로운 필드를 동시에 업데이트하도록 설정
     3. 새 필드를 사용하는 버젼으로 조금씩 교체
     4. 없어진 예전 필드 삭제
## 2.6 리팩터링, 아키첵처, 애그니(YAGNI)
* 실제 개발해 보기전에는, 설계가 가능한지 판단이 가능
  * 결국은 변경에 유연성이 필요한데, 이것을 위해 모든 상황을 고려하다 보면 변화대응에 늦게 된다.
* 리팩터링은 요구사항 변화에 쉽게 대응하도록 코드 베이스를 설계해줌
  * 그냥 현재의 요구사항에 맞춰 개발
  * 요구사항이 바뀌면, 리팩터링
* 간결한 설계, 점진적 설계, YAGNI(you aren't going to need it, 필요없을 거다)
* **선제적 아키텍처가 필여없다는것이 아니다**
## 2.7 리팩터링과 소프트웨어 개발 프로세스 
* 자가 테스트 코드 
* 지속적 통합 (CI)
* 리팩터링 
* 그런데 이게 어렵다. ㅜㅜ
## 2.8 리팩터링과 성능 
* 소프트웨어가 느려 질 수도 있지만, 튜닝하기 더 쉬워진다.
* 시스템에 대해 잘 알아도 추측하지 말고 성능을 측정해봐야 한다.
1. 우선 성능에 대해 신경 쓰지 않고, 다루기 쉬운 코드를 만드는 데 집중
2. 성능최적화 단계시
   3. 프로파일러로 분석 
   4. 큰 영향을 주는 부분을 수정
* 리팩터링된 코드 튜닝시 장점
  * 기능 추가가 빨라져서, 성능에 투자할 시간 늘어남
  * 더 세밀하게 분석이 가능해, 개선안에 대한 아이디어 도출이 용이 
## 2.9 리팩터링의 유래 
## 2.10 리팩터링 자동화 
* 좋은 IDE를 쓰면 됨
* js는 리팩터링 자동화에 좋은 언어는 아님 
## 2.11 책들
* 리팩터링 워크북 (http://www.yes24.com/Product/Goods/2148566)
* 패턴을 활용한 리팩터링 (http://www.yes24.com/Product/Goods/14752528)
* 리팩토링 데이터베이스 (http://www.yes24.com/Product/Goods/2606054)
* 레거시 코드 활용 전략 (http://www.yes24.com/Product/Goods/64586851)
