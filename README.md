# 리팩터링

## 0. 들어가며

- 리팩터링이란
  - 겉으로 드러나는 코드의 기능은 바꾸지 않으면서 내부 구조를 개서하느 방식으로 소프트웨어 시스템을 수정하는 과정
  - 코딩 후 설계 개선
  - 처음부터 완벽한 설계를 갖추기보다는 개발을 진행하면서 지속적으로 설계
- 덕타이핑
  - 자바스크립트에서는 *구조*를 기준으로 타입을 구분한다.
  - 클래스이름과 상관없이 특정 필드와 메서드를 지닌 객체라면 같은 타입으로 간주한다.

## 1. 리팩터링: 첫 번째 예시

- 잘 동작하는 프로그램을 지저분하다고 고쳐도 될까?
  _ 코드를 수정하려면 사람의 개입이 필요
  _ 사람은 코드의 미적 상태에 민감
  _ 설계가 나쁜 시스템은 수정이 어렵다.
  _ 무엇을 수정할지 찾기가 어려우면 실수로 인한 버그 가능성 높아짐
  > 프로그램이 새로운 기능을 추가하기에 편한 구조가 아니라면, 먼저 기능을 추가하기 쉬운 형태로 리팩터링하고 원하는 기능을 추가한다.

## 1.4 statement() 함수 쪼개기

- 함수 추출하기 (extract method, option+command+M) - (29-33)
  - let thisAmount = 0 부터 스위치문 끝까지 선택후 함수 추출하면 자동으로 적용 가능
  - 이렇게 조금씩 변경하고 매번 테스트하는 것이 리팩터링의 핵심
    > 리팩터링은 프로그램 수정을 작은 단계로 나눠 진행한다. 그래서 중간에 실수하더라도 버그를 쉽게 찾을 수 있다.
  - 테스트는 실행할 때 --watch 옵션을 줘서, 파일 변경시 계속 확인하도록 함
- 함수 추출후 추출된 함수 검토(33-35)
  - WebStorm에서 추출한 함수의 파라미터는 (play, perf)였음. 책의 내용처럼 (perf, play)로 변경
  - 이때는 Change Signature (Command+F6) 사용
- play 변수제거 (35-37)
  - 책의 의도를 잘못 파악하고 amountFor를 global로 뺐기에 다시 안으로 집어넣고, playFor 함수 추출
  - 변수 인라인하기 (Inline, option+command+n)
- amountFor에서 play 제거하기 (37-39)
  - Ide에서는 제공하지 않으니, const play=playFor(aPerformance) 로 변경후 inline
- thisAmount를 인라인 (39-40)
  - 사실 이정도까지 인라인해도 속도에는 크게 영향이 없는 것을 알지만, 가슴에서 거부한다.
- 적립 포인트 계산 코드 추출하기(40-42)
  - volumeCredits += ... ~~~ if문 끝나는데까지 선택후 함수 추출
- format 변수 제거하기 및 이름변경 (42-44)
  - 변수 제거는 완벽하게 자동은 안 됨. const format= 이후부터 선택해서 함수 추출 후 수동으로 aNumber 추가
- volumeCredits 변수 제거하기 (44-47)
  - 반복문 쪼개기로 volumeCredits 사용 로직 분리
    - 으윽. 이것도 가슴이 거부. 하지만 함수형에서는 편안한 마음으로 하고 있다는게 아이러니.
  - 이건 자동으로 안 되니, 루프 통째로 복사후 불필요 부분 제거
  - volumeCredits 세팅하는 부분을 함수 추출후 인라인처리
    > 반복문 중복으로 인한 성능저하 문제가 걱정될 수 있다.
    > 이런 중복은 성능에 크게 영향을 주지 않을 뿐더러, 컴파일러들이 우리의 직관을 초월하는 결과를 만들기도 한다.
    > 그렇지만 항상 상관없는 것은 아니기에 리팩터링후 성능이 떨어졌으면 나중에 성능을 개선하는 작업을 따로 실시한다.
    > 이미 좋은 코드로 바뀌었기 때문에 성능 개선을 더 효과적으로 할 수 있다.
    > 결론적으로 더 깔끔하면서도 더 빠른 코드를 얻을 수 있다는 것
- totalAmount 변수 제거 (47-49)
  - 반복문 쪼개기, 변수초기화 구문 이동, 함수 추출, 임시 변수명 사용, 인라인, 이름 변경, 함수내 이름 변경

## 1.5 중간 점검: 난무하는 중첩 함수

- 중첩함수를 써서 이거 별로인데 했는데, 이제 이걸 고치는군
- 인줄 알았는데, 그냥 놔두고 있음.

## 1.6 계산 단계와 포맷팅 단계 분리하기

- 이 부분이 사실 핵심이 아닐까 생각한다.
  1. statement()에 필요한 데이터를 처리하고
  2. 처리한 결과를 텍스트나 HTML로 표현
- statement 전체를 함수 추출 후, data를 넘기도록 변경 (52-53)
- customer, performances 정보를 data로 이동 (54-55)
  - performances를 얕은 복사를 사용. 책에서와는 다르게 그냥 es6 기능 사용
- playFor / amountFor, volumeCreditsFor 함수 옮기기 및 data.performances에 저장(55-57)
- totalAmount / totalVolumeCredits 이동 (58-59)
  - 여기에 있는 방식으로 하려면 object를 바로 생성하는 방식 ({a: xxx})가 안 됨.
  - 그래서 {} 선언후 값할당하는 방식으로 변경함
  - 반복문 파이프라인으로 바꾸기는 Ramda써서 바꿔봄 