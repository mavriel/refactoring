# 9. 데이터 조직화

## 9.1 변수 쪼개기 (Split Variable)

### 언제/의견/주의사항

- 긴코드의 결과를 저장하는 변수에 값 대입이 두번 이상 발생할 때
- 변수의 역할이 둘이상이면 만드시 쪼개야 함
- 변수는 무조건 const로 만드는 것을 기본으로 하면 됨.

### 절차

1. 변수를 선언한 곳과 값을 처음 대입하는 곳에서 변수명을 바꾼다.
   - i = i + xxx 형태인 변수는 쪼개면 안 된다.
2. 가능하면 const로 선언
3. 이 변수에 두 번째로 값을 대입하는 곳 앞까지의 모든 참조를 새로운 변수명으로 바꾼다.
4. 두 번째 대입 시 변수를 원래 이름으로 다시 선언한다.
5. 테스트
6. 반복

## 9.2 필드 이름 바꾸기 (Rename Field)

### 언제/의견/주의사항

- 개발을 진행하면서 데이터를 더 잘 이해하게 되고, 깊어진 이해를 프로그램에 반영

### 절차

1. 레코드의 유효 범위가 제한적이라면 필드에 접근하는 모든 코드를 수정후 테스트 (이후 단계 없음)
2. 레코드가 캡슐화되지 않았면 우선 레코드 캡슐화
3. 캡슐화된 객체 안의 private 필드명을 변경하고, 그에 맞게 내부 메서드들 수정
4. 테스트
5. 생성자 매개변수 중 필드와 이름이 겹치는게 있다면 함수 선언 바꾸기
6. 접근자들의 이름 변경

## 9.3 파생 변수를 질의 함수로 바꾸기 (Replace Derived Variable with Query)

### 언제/의견/주의사항

- 가변데이터를 최대한으로 제거하기위한 방법중 하나

### 절차

1. 변수의 값이 갱신되는 지점을 모두 찾는다. 필요시 변수 쪼개기
2. 해당 변수의 값을 계산하는 함수 생성
3. 해당 변수를 사용하는 모든 곳에 어설션을 변수의 값과 함수의 결과가 같은지 확인
4. 테스트
5. 함수로 대체
6. 테스트
7. 변수선언,갱신 코드 제거

## 9.4 참조를 값으로 바꾸기 (Change Reference to Value)

### 언제/의견/주의사항

- 값은 불변이기 때문에, 다루기가 쉽다
- 항상 복사해서 사용하기 때문에 참조를 관리할 필요가 없어서 분산/동시성 시스템에서 유용
- 여러 객체에서 공유하여 사용하는 경우에는 이 리펙터링 적용하면 안 된다.

### 절차

1. 후보 클래스가 불변인지, 혹은 불변이 될 수 있는지 확인
2. 각각의 세터를 하나씩 제거
3. 이 값 객체의 필드들을 사용하는 동치성 비교 메서드 생성

## 9.5 값을 참조로 바꾸기 (Change Value to Reference)

### 언제/의견/주의사항

- 논리적으로 똑같은 데이터 구조를 참조하는 레코드를 복제해 사용하는데, 그 데이터가 갱신되는 경우

### 절차

1. 같은 부류에 속하는 객체들을 보관할 저장소를 만든다.
2. 생성자에서 이 부류의 객체들 중 특정 객체를 정확히 찾아내는 방법이 있는지 확인
3. 호스트 객체의 생성자들을 수정해 필요한 객체를 이 저장소에서 찾도록 한다. 하나 수정할 때마다 테스트

## 9.6 매직 리터럴 바꾸기 (Replacee Magic Literal)

### 언제/의견/주의사항

- 소스 코드에 등장하는 일반적인 값들을 상수로 선언하여 사용
- 값이 맥락에서 의미가 있는경우에만 변경한다.

### 절차

1. 상수를 선언하고 매직 리터럴 대입
2. 해당 리터럴이 사용되는 곳을 모두 찾는다.
3. 찾은 곳 각각에서 리터럴이 새 상수와 똑같은 의미로 쓰였는지 확인. (이 부분이 중요할 듯)
